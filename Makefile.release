#!/usr/bin/make
#
# Copyright 2018 Nomos Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

######################################################################

# Makefile that configures for release.
#
# This file contains all the specific workflow and configuration to create
# a nomos release.
#
# make release - will clean, build, package and push the entire code set to our
# 			release location and move the 'latest' image tag to
# 			the release just built. This must be run from clean
# 			git client.
#
# make bless-release - will move the 'stable' image tag to the release that
# 			was just built.

##### CONFIG #####

# List of GOOS-GOARCH cross compilation targets
PLATFORMS ?= linux-amd64 darwin-amd64 windows-amd64

# GCP project that owns container registry for official releases.
GCP_PROJECT ?= nomos-release

# The GCS bucket containing official releases.
RELEASE_BUCKET ?= gs://nomos-release

FETCH_TAGS := $(shell git fetch --tags)

# Use git tags to set version string.
VERSION := $(shell git describe --tags --always --dirty)

# The version of the last known release candidate, e.g. v1.2.3-rc.4, but could
# also be v1.2.3 if the last release candidate was promoted to a release.
LAST_RC := $(shell git tag --sort=version:refname | tail -n1)

# The version of the last known release (without -rc.X), e.g. v1.2.3
LAST_RELEASE := $(shell git tag --sort=version:refname | grep -v "rc" | tail -n1)

# Set the IMAGE_TAG to only include the version info and no other build info.
IMAGE_TAG := $(VERSION)

# Enable optimzations.
BUILD_MODE ?= release

##### SETUP ######

include Makefile

##### Post-setup env variable evaulations #####

# Finds any backwards incompatible changes since last tagged release candidate.
BACKWARDS_INCOMPATIBLE_RC := $(shell \
		git log $(LAST_RC)..$(NEXT_RC) | grep 'BACKWARDS INCOMPATIBLE')

# Finds any backwards incompatible changes since last tagged full release.
BACKWARDS_INCOMPATIBLE_RELEASE := $(shell \
		git log $(LAST_RELEASE)..$(NEXT_RC) | grep 'BACKWARDS INCOMPATIBLE')

# Finds the next minor release after the last release candidate.
# v1.2.3-rc.4 -> v1.3.0
# v1.2.3      -> v1.3.0
NEXT_MINOR_RELEASE := $(shell \
		docker run --rm $(BUILDENV_IMAGE) sembump $(LAST_RC) | \
		xargs docker run --rm $(BUILDENV_IMAGE) sembump --kind=minor)

# If a release candidate has backwards incompatible changes with respect to
# last one built, then increment the minor version to denote that.
# TODO(filmil): Re-verify reasoning about semver jump-around since it's a bit
# involved.
HAS_BACKWARDS_INCOMPATIBLE := $(shell \
		[ -n "$(BACKWARDS_INCOMPATIBLE_RC)" ] && echo 1 || echo 0)
ifeq ($(HAS_BACKWARDS_INCOMPATIBLE),0)
  # v1.2.3-rc.4 -> v1.2.3-rc.5
  # v1.2.3      -> v1.2.3-rc.1
  NEXT_RC = $(shell docker run --rm $(BUILDENV_IMAGE) sembump -pre $(LAST_RC))
else
  # v1.2.3-rc.4 -> v1.3.0-rc.1
  # v1.2.3      -> v1.3.0-rc.1
  NEXT_RC = $(NEXT_MINOR_RELEASE)-rc.1
endif

##### TARGETS #####

# Checks the version tag to see if its dirty.  We should never release from
# a dirty git client.
check-dirty:
	@echo "VERSION=$(VERSION)"
	@bash -c '\
		if [[ $(VERSION) == *"dirty"* ]]; then \
		echo "Cannot release from a dirty client: VERSION=$(VERSION)"; \
		exit 1; \
	fi\
	'

$(STAGING_DIR)/installer.zip: \
		installer-staging \
		$(wildcard $(STAGING_DIR)/installer/*)
	@echo "+++ Building installer archive: $@"
	@(cd .output/staging ; zip -r $@ installer)

# Unconditional upload of nomos artifacts tagged with $(IMAGE_TAG) to gcr.io.
upload-release:
	@echo "+++ Marking release $(IMAGE_TAG) as 'latest'"
	gsutil -m cp -R \
		$(STAGING_DIR)/installer.zip \
		$(STAGING_DIR)/nomos-docs.zip  \
	    $(BIN_DIR) \
		$(RELEASE_BUCKET)/$(VERSION)
	gsutil acl ch -r -u AllUsers:R $(RELEASE_BUCKET)/$(VERSION)
	gcloud container images add-tag --quiet \
		gcr.io/$(GCP_PROJECT)/nomos:$(IMAGE_TAG) \
		gcr.io/$(GCP_PROJECT)/nomos:latest
	gsutil -m rsync -r -d -p \
			$(RELEASE_BUCKET)/$(VERSION) \
			$(RELEASE_BUCKET)/latest

# Uploads the release artifacts to a versioned GCS release bucket. Also uploads
# the artifacts to a GCS release bucket with version name "latest".
release: \
		clean \
		test-all \
		$(STAGING_DIR)/installer.zip \
		docs-package \
		upload-release

# For releases we attach the :stable tag to the latest image
# built and update the stable docs package.  Dirty package releases  are not
# allowed.
bless-release: check-dirty
	@echo "+++ Marking release $(IMAGE_TAG) as 'stable'"
	gcloud container images add-tag --quiet \
		gcr.io/$(GCP_PROJECT)/nomos:$(IMAGE_TAG) \
		gcr.io/$(GCP_PROJECT)/nomos:stable
	gsutil -m rsync -r -d -p \
		$(RELEASE_BUCKET)/$(VERSION) \
		$(RELEASE_BUCKET)/stable

##### Git operations as make targets #####

# Ensures that tags are fetched from the git repository.
git-tag:
	git tag --sort=version:refname

# Commits the NEXT_RC release tag.
git-tag-commit:
	git tag -a $(NEXT_RC) -m "Release candidate $(NEXT_RC)"

# Uploads a newly-tagged NEXT_RC (e.g. v1.2.3-rc.4)
git-tag-upload:
	$(info +++ Uploading tag $(NEXT_RC))
	git push origin $(NEXT_RC)

git-relnotes-rc:
	$(info +++ Relnotes for $(LAST_RC)..$(NEXT_RC))
	git log $(LAST_RC)..$(NEXT_RC)
	$(info +++ ----)

# Release target used by automated releaser on go/prow.  It keeps building
# ever-newer release candidates from the HEAD rev of master.
#
# The __internal-* target is split out because the build process must redefine
# VERSION and IMAGE_TAG to tag the release correctly.
# TODO(filmil): This makes the version tags on the YAML files always reference
# release candidates.  This doesn't seem to be a big problem though.
# TODO(filmil): Remove the repetition in this target and the -local one.
autorelease: \
		info \
		check-dirty \
		clean \
	    test \
		ci-test-e2e \
		$(STAGING_DIR)/installer.zip \
		docs-package \
		upload-release

__internal-autorelease: VERSION=$(NEXT_RC)
__internal-autorelease: IMAGE_TAG=$(NEXT_RC)
__internal-autorelease: \
		git-tag \
		info \
		clean \
	    test \
		ci-test-e2e \
		$(STAGING_DIR)/installer.zip \
		docs-package \
		upload-release \
		git-tag-commit \
		git-tag-upload \
		git-relnotes-rc
	$(info +++ Completed releasing $(NEXT_RC))

# Same as 'autorelease', except rigged so that it works on a local machine.
autorelease-local: \
		__internal-autorelease-local

__internal-autorelease-local: VERSION=$(NEXT_RC)
__internal-autorelease-local: IMAGE_TAG=$(NEXT_RC)
__internal-autorelease-local: \
		git-tag \
		info \
		clean \
	    test \
		ci-test-e2e-local \
		$(STAGING_DIR)/installer.zip \
		docs-package \
		upload-release \
		git-tag-commit \
		git-tag-upload \
		git-relnotes-rc
	$(info +++ Completed releasing $(NEXT_RC) [LOCAL RELEASE])

define bless_autorelease_instructions =
+++
+++ Bless an automated release from go/nomos-releaser
+++
+++
+++ Previous release tag:                             $(LAST_RELEASE)
+++ Last release candidate tag found in the git repo: $(LAST_RC)
+++ Proposed release tag:                             $(NEXT_RELEASE)
+++
+++ Proposed changelog is below.
endef

# Promote the latest release candidate
bless-autorelease: NEXT_RELEASE=$(shell \
		docker run --rm $(BUILDENV_IMAGE) sembump $(LAST_RC))
bless-autorelease:
	$(info $(bless_autorelease_instructions))
	TZ=America/Los_Angeles \
  	  git log \
	     --pretty="format:%C(yellow)%h %C(cyan)%>(12,trunc)%cd %C(green)%<(24,trunc)%aN%C(reset)%s" \
	  --date=local \
	  $(LAST_RELEASE)..$(LAST_RC)
	@bash -c '\
			read -p "Release candidate to promote (default=$(LAST_RC)): " chosen_rc;           \
	        chosen_rc="$${chosen_rc:-$(LAST_RC)}";                                         \
			read -p "Blessed release version      (default=$(NEXT_RELEASE)): " chosen_release; \
	        chosen_release="$${chosen_release:-$(NEXT_RELEASE)}";                          \
		    echo "Chosen:  $${chosen_release}";                                            \
			echo "RC:      $${chosen_rc}";                                                 \
			git tag -a $${chosen_release} -m "Blessed release $${chosen_release}" ; \
			gcloud container images add-tag --quiet                                        \
			   gcr.io/$(GCP_PROJECT)/nomos:$${chosen_rc}                                   \
			   gcr.io/$(GCP_PROJECT)/nomos:$${chosen_release} ;                            \
			gcloud container images add-tag --quiet                                        \
			   gcr.io/$(GCP_PROJECT)/nomos:$${chosen_release}                              \
			   gcr.io/$(GCP_PROJECT)/nomos:stable ;                                        \
			gsutil -m rsync -r -d -p                                                       \
			   $(RELEASE_BUCKET)/$${chosen_rc}                                             \
			   $(RELEASE_BUCKET)/$${chosen_release} ;                                      \
			gsutil -m rsync -r -d -p                                                       \
			   $(RELEASE_BUCKET)/$${chosen_release}                                        \
			   $(RELEASE_BUCKET)/stable ;                                                  \
			git push origin $${chosen_release};                                            \
			echo -e "\nRelease notes $(LAST_RELEASE)..$${chosen_release}:\n"; \
			TZ=America/Los_Angeles \
			  git log \
			     --pretty="format:%C(yellow)%h %C(cyan)%>(12,trunc)%cd %C(green)%<(24,trunc)%aN%C(reset)%s" \
                 --date=local $(LAST_RELEASE)..$${chosen_release} ; \
	'

	
#############################################################################
# Various release info printed for diagnostics.

info:
	$(info +++ Releasing version:            $(IMAGE_TAG))
	$(info +++ Last known release candidate: $(LAST_RC))
	$(info +++ Next minor release:       $(NEXT_MINOR_RELEASE))
	$(info +++ Last known blessed release:   $(LAST_RELEASE))
	$(info +++ Next release candidate:       $(NEXT_RC))
	$(info +++ Backwards incompatible from RC:      $(BACKWARDS_INCOMPATIBLE_RC))
	$(info +++ Backwards incompatible from RELEASE: $(BACKWARDS_INCOMPATIBLE_RELEASE))
	$(info +++ Incompatible:                 $(HAS_BACKWARDS_INCOMPATIBLE))
	$(info +++ Building version: $(VERSION); $(IMAGE_TAG))

