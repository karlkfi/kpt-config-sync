#!/usr/bin/make
#
# Copyright 2018 Nomos Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

######################################################################

# Makefile that configures for release.
#
# This file contains all the specific workflow and configuration to create
# a nomos release.
#
# make release - will clean, build, package and push the entire code set to our
# 			release location and move the 'latest' image tag to
# 			the release just built. This must be run from clean
# 			git client.
#
# make bless-release - will move the 'stable' image tag to the release that
# 			was just built.

##### CONFIG #####

# List of GOOS-GOARCH cross compilation targets
PLATFORMS ?= linux-amd64 darwin-amd64 windows-amd64

# GCP project that owns container registry for official releases.
GCP_PROJECT ?= nomos-release

# GCR prefix to locate containers. For release it is just the GCP Project name.
GCR_PREFIX ?= $(GCP_PROJECT)

# The GCS bucket containing official releases.
RELEASE_BUCKET ?= gs://nomos-release

FETCH_TAGS := $(shell git fetch --tags)

# Use git tags to set version string.
VERSION := $(shell git describe --tags --always --dirty)

# TODO(filmil): See if we can avoid referring explicitly to the internal
# repository.
NOMOS_GIT_REPO := https://team.googlesource.com/gke-kubernetes-enterprise-control/prototype

##### SETUP ######

include Makefile

##### Post-setup env variable evaulations #####

# The version of the last known release candidate, e.g. v1.2.3-rc.4, but could
# also be v1.2.3 if the last release candidate was promoted to a release.
LAST_RC := $(shell \
		git tag --sort=version:refname | \
		docker run -i $(BUILDENV_IMAGE) semsort 2>&1 | \
		tail -n 1)

# The version of the last known release (without -rc.X), e.g. v1.2.3
LAST_RELEASE := $(shell \
		git tag --sort=version:refname | \
		grep -v "rc" | \
		docker run -i $(BUILDENV_IMAGE) semsort 2>&1 | \
		tail -n 1)

# Set the IMAGE_TAG to only include the version info and no other build info.
IMAGE_TAG := $(VERSION)

# Enable optimzations.
BUILD_MODE ?= release

# This is the hash of the last release candidate's revision.  No need to run the
# release process if this has not changed since the last run.
LAST_RC_GIT_HASH := $(shell git rev-list -n 1 $(LAST_RC))

# This is the hash of the current git HEAD
HEAD_GIT_HASH := $(shell git rev-parse HEAD)

# Finds any backwards incompatible changes since last tagged release candidate.
BACKWARDS_INCOMPATIBLE_RC := $(shell \
		git log $(LAST_RC)..$(NEXT_RC) | grep 'BACKWARDS INCOMPATIBLE')

# Finds any backwards incompatible changes since last tagged full release.
BACKWARDS_INCOMPATIBLE_RELEASE := $(shell \
		git log $(LAST_RELEASE)..$(NEXT_RC) | grep 'BACKWARDS INCOMPATIBLE')

BUMP_LAST_RC := $(shell \
		docker run --rm $(BUILDENV_IMAGE) sembump $(LAST_RC) | \
		xargs docker run --rm $(BUILDENV_IMAGE) sembump --kind=minor)
BUMP_LAST_RELEASE := $(shell \
		docker run --rm $(BUILDENV_IMAGE) sembump --kind=minor $(LAST_RELEASE))
# Finds the next minor version number that comes after both LAST_RELEASE and
# LAST_RC.
#
# Example:
#   LAST_RELEASE=v0.10.4, LAST_RC=v0.11.0-rc.2 => NEXT_MINOR_RELEASE=v0.11.0
#   LAST_RELEASE=v0.10.4, LAST_RC=v0.10.3-rc.5 => NEXT_MINOR_RELEASE=v0.11.0
NEXT_MINOR_RELEASE := \
  $(shell echo "$(BUMP_LAST_RC) $(BUMP_LAST_RELEASE)" | \
    docker run -i $(BUILDENV_IMAGE) semsort 2>&1 | head -n 1)

# If a release candidate has backwards incompatible changes with respect to
# last one built, then increment the minor version to denote that.
# TODO(filmil): Re-verify reasoning about semver jump-around since it's a bit
# involved.
HAS_BACKWARDS_INCOMPATIBLE := $(shell \
		[ -n "$(BACKWARDS_INCOMPATIBLE_RC)" ] && echo 1 || echo 0)
ifeq ($(HAS_BACKWARDS_INCOMPATIBLE),0)
  # v1.2.3-rc.4 -> v1.2.3-rc.5
  # v1.2.3      -> v1.2.3-rc.1
  NEXT_RC = $(shell docker run --rm $(BUILDENV_IMAGE) sembump -pre $(LAST_RC))
else
  # What would be the next release candidate without an incompatible change?
  # LAST_RC=v0.10.3-rc.2 => NEXT_RC_WITHOUT=v0.10.3-rc.3
  NEXT_RC_WITHOUT = \
    $(shell docker run --rm $(BUILDENV_IMAGE) sembump -pre $(LAST_RC))
  # What would be the next release candidate if there *is* an incompatible
  # change?  It's the first minor release that follows both the
  # NEXT_MINOR_RELEASE and the last release candidate that would have been used
  # if there were no incompatible changes.
  #
  # Example:
  # (1)
  #   NEXT_MINOR_RELEASE=v0.11.0
  #   NEXT_RC_WITHOUT=v0.10.4
  #   => NEXT_RC=v0.11.0-rc.1
  # (2)
  #   NEXT_MINOR_RELEASE=v0.11.0
  #   NEXT_RC_WITHOUT=v0.11.0-rc.1
  #   => NEXT_RC=v0.11.0-rc.2
  NEXT_RC = \
    $(shell echo "$(NEXT_MINOR_RELEASE)-rc.1 $(NEXT_RC_WITHOUT)" | \
	 docker run -i $(BUILDENV_IMAGE) semsort 2>&1 | tail -n 1)
endif

##### TARGETS #####

# Checks the version tag to see if its dirty.  We should never release from
# a dirty git client.
check-dirty:
	@echo "VERSION=$(VERSION)"
	@bash -c '\
		if [[ $(VERSION) == *"dirty"* ]]; then \
		echo "Cannot release from a dirty client: VERSION=$(VERSION)"; \
		exit 1; \
	fi\
	'

$(STAGING_DIR)/installer.zip: \
		installer-staging \
		$(wildcard $(STAGING_DIR)/installer/*)
	@echo "+++ Building installer archive: $@"
	@(cd .output/staging ; zip -r $@ installer)

# Unconditional upload of nomos artifacts tagged with $(IMAGE_TAG) to gcr.io.
upload-release:
	@echo "+++ Marking release $(IMAGE_TAG) as 'latest'"
	gsutil -m cp -R \
		$(STAGING_DIR)/installer.zip \
		$(STAGING_DIR)/nomos-docs.zip  \
		$(STAGING_DIR)/kubectl-oidc/kubectl-oidc-plugin.zip  \
	    $(BIN_DIR) \
		$(RELEASE_BUCKET)/$(VERSION)
	gsutil acl ch -r -u AllUsers:R $(RELEASE_BUCKET)/$(VERSION)
	gcloud container images add-tag --quiet \
		gcr.io/$(GCR_PREFIX)/nomos:$(IMAGE_TAG) \
		gcr.io/$(GCR_PREFIX)/nomos:latest
	gsutil -m rsync -r -d -p \
			$(RELEASE_BUCKET)/$(VERSION) \
			$(RELEASE_BUCKET)/latest

# Uploads the release artifacts to a versioned GCS release bucket. Also uploads
# the artifacts to a GCS release bucket with version name "latest".
release: \
		clean \
		test \
		ci-test-e2e \
		$(STAGING_DIR)/installer.zip \
		docs-package \
		upload-release

# For releases we attach the :stable tag to the latest image
# built and update the stable docs package.  Dirty package releases  are not
# allowed.
bless-release: check-dirty
	@echo "+++ Marking release $(IMAGE_TAG) as 'stable'"
	gcloud container images add-tag --quiet \
		gcr.io/$(GCR_PREFIX)/nomos:$(IMAGE_TAG) \
		gcr.io/$(GCR_PREFIX)/nomos:stable
	gsutil -m rsync -r -d -p \
		$(RELEASE_BUCKET)/$(VERSION) \
		$(RELEASE_BUCKET)/stable

##### Git operations as make targets #####

# Where the "origin" remote is not defined, define it.   go/prow jobs don't have
# it defined, and this matters in the 'autorelease' target below.
git-remote-add:
	git remote add origin $(NOMOS_GIT_REPO)

# Ensures that tags are fetched from the git repository.
git-tag:
	git fetch --tag

# Commits the NEXT_RC release tag.
git-tag-commit:
	git tag -a $(NEXT_RC) -m "Release candidate $(NEXT_RC)"

# Uploads a newly-tagged NEXT_RC (e.g. v1.2.3-rc.4)
git-tag-upload:
	$(info +++ Uploading tag $(NEXT_RC))
	git push origin $(NEXT_RC)

git-relnotes-rc:
	$(info +++ Relnotes for $(LAST_RC)..$(NEXT_RC))
	git log $(LAST_RC)..$(NEXT_RC)
	$(info +++ ----)

# Release target used by automated releaser on go/prow.  It keeps building
# ever-newer release candidates from the HEAD rev of master.
#
# The __internal-* target is split out because the build process must redefine
# VERSION and IMAGE_TAG to tag the release correctly.
# TODO(filmil): This makes the version tags on the YAML files always reference
# release candidates.  This doesn't seem to be a big problem though.
# TODO(filmil): Remove the repetition in this target and the -local one.
autorelease: \
		__internal-autorelease

ifeq ($(LAST_RC_GIT_HASH), $(HEAD_GIT_HASH))
# No need to do any work if we didn't commit any changes since last release
# candidate had been built.
__internal-autorelease:
	$(info +++ Git has has not changed since $(LAST_RC).  Nothing to do.)
else
__internal-autorelease: VERSION=$(NEXT_RC)
__internal-autorelease: IMAGE_TAG=$(NEXT_RC)
__internal-autorelease: \
		git-remote-add \
		git-tag \
		info \
		clean \
	    test \
		ci-test-e2e \
		$(STAGING_DIR)/installer.zip \
		docs-package \
		upload-release \
		git-tag-commit \
		git-tag-upload \
		git-relnotes-rc
	$(info +++ Completed releasing $(NEXT_RC))
endif

# Same as 'autorelease', except rigged so that it works on a local machine.
autorelease-local: \
		__internal-autorelease-local

ifeq ($(LAST_RC_GIT_HASH), $(HEAD_GIT_HASH))
# No need to do any work if we didn't commit any changes since last release
# candidate had been built.
__internal-autorelease-local:
	$(info +++ Git has has not changed since $(LAST_RC).  Nothing to do.)
else
__internal-autorelease-local: VERSION=$(NEXT_RC)
__internal-autorelease-local: IMAGE_TAG=$(NEXT_RC)
__internal-autorelease-local: \
		git-tag \
		info \
		clean \
	    test \
		ci-test-e2e-local \
		$(STAGING_DIR)/installer.zip \
		docs-package \
		upload-release \
		git-tag-commit \
		git-tag-upload \
		git-relnotes-rc
	$(info +++ Completed releasing $(NEXT_RC) [LOCAL RELEASE])
endif

define bless_autorelease_instructions =
+++
+++ Bless an automated release from go/nomos-releaser
+++
+++
+++ Previous release tag:                             $(LAST_RELEASE)
+++ Last release candidate tag found in the git repo: $(LAST_RC)
+++ Proposed release tag:                             $(NEXT_RELEASE)
+++
+++ Proposed changelog is below.
endef

# Promote the latest release candidate
bless-autorelease: NEXT_RELEASE=$(shell \
		docker run --rm $(BUILDENV_IMAGE) sembump $(LAST_RC))
bless-autorelease:
	$(info $(bless_autorelease_instructions))
	TZ=America/Los_Angeles \
  	  git log \
	     --pretty="format:%C(yellow)%h %C(cyan)%>(12,trunc)%cd %C(green)%<(24,trunc)%aN%C(reset)%s" \
	  --date=local \
	  $(LAST_RELEASE)..$(LAST_RC)
	@bash -c '\
			read -p "Release candidate to promote (default=$(LAST_RC)): " chosen_rc;           \
	        chosen_rc="$${chosen_rc:-$(LAST_RC)}";                                         \
			read -p "Blessed release version      (default=$(NEXT_RELEASE)): " chosen_release; \
	        chosen_release="$${chosen_release:-$(NEXT_RELEASE)}";                          \
		    echo "Chosen:  $${chosen_release}";                                            \
			echo "RC:      $${chosen_rc}";                                                 \
			git tag -a $${chosen_release} $${chosen_rc}                                    \
			   -m "Blessed release $${chosen_release}" ;                                   \
			gcloud container images add-tag --quiet                                        \
			   gcr.io/$(GCR_PREFIX)/nomos:$${chosen_rc}                                   \
			   gcr.io/$(GCR_PREFIX)/nomos:$${chosen_release} ;                            \
			gcloud container images add-tag --quiet                                        \
			   gcr.io/$(GCR_PREFIX)/nomos:$${chosen_release}                              \
			   gcr.io/$(GCR_PREFIX)/nomos:stable ;                                        \
			gsutil -m rsync -r -d -p                                                       \
			   $(RELEASE_BUCKET)/$${chosen_rc}                                             \
			   $(RELEASE_BUCKET)/$${chosen_release} ;                                      \
			gsutil -m rsync -r -d -p                                                       \
			   $(RELEASE_BUCKET)/$${chosen_release}                                        \
			   $(RELEASE_BUCKET)/stable ;                                                  \
			git push origin $${chosen_release};                                            \
			echo -e "\nRelease notes $(LAST_RELEASE)..$${chosen_release}:\n"; \
			TZ=America/Los_Angeles \
			  git log \
			     --pretty="format:%C(yellow)%h %C(cyan)%>(12,trunc)%cd %C(green)%<(24,trunc)%aN%C(reset)%s" \
                 --date=local $(LAST_RELEASE)..$${chosen_release} ; \
	'


#############################################################################
# Various release info printed for diagnostics.

info:
	$(info +++)
	$(info +++ RELEASE CANDIDATE INFORMATION)
	$(info +++)
	$(info +++ Last blessed version:             $(LAST_RELEASE))
	$(info +++ Last release candidate:           $(LAST_RC))
	$(info +++ Next release candidate:           $(NEXT_RC))
	$(info +++)
	$(info +++ Last release candidate commit ID: $(LAST_RC_GIT_HASH))
	$(info +++ Next release candidate commit ID: $(HEAD_GIT_HASH))
	$(info +++)
	$(info +++ Diagnostics (to be removed once the process is validated): )
	$(info +++ BACKWARDS_INCOMPATIBLE_RC:        $(BACKWARDS_INCOMPATIBLE_RC))
	$(info +++ BACKWARDS_INCOMPATIBLE_RELEASE:   $(BACKWARDS_INCOMPATIBLE_RELEASE))
	$(info +++ HAS_BACKWARDS_INCOMPATIBLE:       $(HAS_BACKWARDS_INCOMPATIBLE))
	$(info +++ IMAGE_TAG:                        $(IMAGE_TAG))
	$(info +++ NEXT_MINOR_RELEASE:               $(NEXT_MINOR_RELEASE) [after $(LAST_RELEASE)])
	$(info +++ VERSION:                          $(VERSION))

