// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package git provides functionality related to Git repos.
package git

import (
	"fmt"
	"io/ioutil"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/pkg/errors"
	"kpt.dev/configsync/pkg/api/configsync"
	"kpt.dev/configsync/pkg/importer/filesystem/cmpath"
)

const (
	// ErrorFile is the file name of the git-sync error file.
	ErrorFile = "error.json"
)

// Deprecated: Only used by the legacy mono-repo mode.
var gitSyncDirPattern = regexp.MustCompile(`^[a-f|0-9]{40}$`)

// CommitHash parses the Git commit hash from the given directory path.
// Deprecated: Only used by the legacy mono-repo mode.
func CommitHash(dirPath string) (string, error) {
	dirName := filepath.Base(dirPath)

	if !gitSyncDirPattern.MatchString(dirName) {
		return "", errors.Errorf("directory name %q is not a git commit hash", dirPath)
	}
	return dirName, nil
}

// CheckClean returns an error if the repo pointed to by dir is not clean, or there was an error invoking Git while
// checking.
// Deprecated: Only used by the legacy mono-repo mode.
func CheckClean(dir string) error {
	cmd := exec.Command("git", "-C", dir, "status", "--short")
	outBytes, err := cmd.CombinedOutput()
	out := string(outBytes)
	if err != nil {
		return errors.Wrapf(err, "checking for clean working directory: failed to call git status on dir %s, output: %s", dir, out)
	}
	if out != "" {
		return errors.Errorf("git status returned dirty working tree: %s", out)
	}
	return nil
}

// ListFiles returns a list of all files tracked by git in the specified
// repo directory.
// Deprecated: Only used by the legacy mono-repo mode.
func ListFiles(dir cmpath.Absolute) ([]cmpath.Absolute, error) {
	out, err := exec.Command("git", "-C", dir.OSPath(), "ls-files").CombinedOutput()
	if err != nil {
		return nil, errors.Wrap(err, string(out))
	}
	files := strings.Split(string(out), "\n")
	var result []cmpath.Absolute
	// The output from git ls-files, when split on newline, will include an empty string at the end which we don't want.
	for _, f := range files[:len(files)-1] {
		// The result of git ls-files is paths relative to the current working
		// directory, so we have to convert these to absolute paths.
		abs, err := dir.Join(cmpath.RelativeOS(f)).EvalSymlinks()
		if err != nil {
			return nil, errors.Wrapf(err, "error getting absolute path for %q", f)
		}
		result = append(result, abs)
	}

	// git submodule foreach --recursive git ls-files
	out, err = exec.Command("git", "-C", dir.OSPath(), "submodule",
		// Execute the command for every submodule.
		"foreach",
		// Recursively execute the command for every submodule's submodule.
		"--recursive",
		// List the files in the submodule.
		"git", "ls-files").
		CombinedOutput()
	if err != nil {
		return nil, errors.Wrap(err, string(out))
	}

	lines := strings.Split(string(out), "\n")
	prefix := ""
	for _, l := range lines {
		if len(l) == 0 {
			// If the repo has no submodules, lines is just [""] and we want to ignore that.
			continue
		}
		// Before entering a submodule, git prints the path from the root of the
		// repository to the submodule. For example:
		// Entering 'namespaces/foo'
		if strings.HasPrefix(l, "Entering '") {
			prefix = l[10 : len(l)-1]
			continue
		}
		abs := dir.Join(cmpath.RelativeOS(prefix)).Join(cmpath.RelativeOS(l))
		result = append(result, abs)
	}

	return result, nil
}

// SyncError returns the error details from the error file generated by the git-sync|oci-sync process.
func SyncError(container, filepath, label string) string {
	content, err := ioutil.ReadFile(filepath)
	if err != nil {
		return fmt.Sprintf("Unable to load %s: %v. Please check %s logs for more info: kubectl logs -n %s -l %s -c %s", filepath, err, container, configsync.ControllerNamespace, label, container)
	}
	if len(content) == 0 {
		return fmt.Sprintf("%s is empty. Please check %s logs for more info: kubectl logs -n %s -l %s -c %s", filepath, container, configsync.ControllerNamespace, label, container)
	}
	return fmt.Sprintf("Error in the %s container: %s", container, string(content))
}
