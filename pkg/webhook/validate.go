package webhook

import (
	"context"

	"github.com/GoogleContainerTools/kpt/pkg/live"
	"github.com/golang/glog"
	v1 "github.com/google/nomos/pkg/api/configmanagement/v1"
	"github.com/google/nomos/pkg/api/configsync"
	"github.com/google/nomos/pkg/api/configsync/v1alpha1"
	"github.com/google/nomos/pkg/declared"
	"github.com/google/nomos/pkg/kptapplier"
	"k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/discovery"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/cli-utils/pkg/common"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// Validator is the part of the validating webhook which handles admission
// requests and admits or denies them.
type Validator struct {
	differ *ObjectDiffer
}

var _ admission.Handler = &Validator{}

// Handler returns a validator which satisfies the admission.Handler interface.
func Handler(cfg *rest.Config) (*Validator, error) {
	dc, err := discovery.NewDiscoveryClientForConfig(cfg)
	if err != nil {
		return nil, err
	}
	vc, err := declared.NewValueConverter(dc)
	if err != nil {
		return nil, err
	}
	return &Validator{&ObjectDiffer{vc}}, nil
}

// Handle implements admission.Handler
func (v *Validator) Handle(ctx context.Context, req admission.Request) admission.Response {
	if reason := skipValidation(req); reason != "" {
		// This admission controller is part of a defense-in-depth strategy. Config
		// Sync is still running a reconciler which will revert any unwanted changes
		// that get through. If the request does not meet all the preconditions for
		// it to be validated, we will fail open and allow the reconciler to revert
		// any changes as necessary.
		return admission.Allowed(reason)
	}

	// Check UserInfo for ConfigSync and perform manager precedence check.
	if isConfigSyncSA(req.UserInfo) {
		if isImporter(req.UserInfo.Username) {
			return admission.Allowed("Config Sync importer can always update a resource")
		}
		// TODO(b/160786209): Add manager precedence checks once service accounts are known for root and repo reconcilers.
	}

	// Handle the requests for ResourceGroup CRs.
	if isResourceGroupRequest(req) {
		return handleResourceGroupRequest(req)
	}

	// TODO(b/160786928): Build diff list between old and new objects

	// TODO(b/160786679): If the diff list includes any ConfigSync labels or annotations, reject the request immediately.

	// TODO(b/160786679): Use the ConfigSync managed fields annotation to build an “immutable list” of which fields should not be modified.
	// TODO(b/160786679): Handle the case where management is being enabled or disabled

	// TODO(b/160786679): If the diff list and immutable list have any fields in common, reject the request. Otherwise allow it.

	return admission.Allowed("")
}

// skipValidation checks to see if the given Request meets all preconditions for
// validation. If the Request fails to meet any, this returns a string
// describing why the Request should skip validation.
func skipValidation(req admission.Request) string {
	// An admission request for a sub-resource (such as a Scale) will not include
	// the full parent for us to validate until the admission chain is fixed:
	// https://github.com/kubernetes/enhancements/pull/1600
	// Until then, we will not configure the webhook to intercept subresources so
	// this block should never be reached.
	if req.SubResource != "" {
		glog.Errorf("Unable to review admission request for sub-resource: %v", req)
		return "unable to review admission request for sub-resource"
	}

	// Verify that old and/or new objects are managed by Config Sync.
	oldMng, err := isManaged(req.OldObject.Object)
	if err != nil {
		glog.Errorf("Unable to read annotations from old object: %v", req.OldObject.Object)
		return "unable to read annotations from old object"
	}
	mng, err := isManaged(req.Object.Object)
	if err != nil {
		glog.Errorf("Unable to read annotations from new object: %v", req.Object.Object)
		return "unable to read annotations from new object"
	}
	// The webhook should be configured to only intercept resources which are
	// managed by Config Sync.
	if !oldMng && !mng {
		glog.Warningf("Received admission request for unmanaged object: %v", req.OldObject.Object)
		return "object is not managed by Config Sync"
	}

	return ""
}

var metadataAccessor = meta.NewAccessor()

func isManaged(obj runtime.Object) (bool, error) {
	annots, err := metadataAccessor.Annotations(obj)
	if err != nil {
		return false, err
	}
	return annots[v1.ResourceManagementKey] == v1.ResourceManagementEnabled, nil
}

// isResourceGroupRequest returns true if the request is for a ResourceGroup CR.
func isResourceGroupRequest(req admission.Request) bool {
	gk := schema.GroupKind{
		Group: req.Kind.Group,
		Kind:  req.Kind.Kind,
	}
	return gk == live.ResourceGroupGVK.GroupKind()
}

// handleResourceGroupRequest handles the request with following rules:
// If the ResourceGroup CR is generated by ConfigSync, users can't modify it.
// If the ResourceGroup CR is not generated by ConfigSync, users can modify it.
func handleResourceGroupRequest(req admission.Request) admission.Response {
	fromConfigSync, err := fromConfigSync(req)
	if err != nil {
		glog.Errorf("Unable to read labels from new object: %v", req.Object.Object)
		reason := "unable to read labels from the new object"
		return admission.Allowed(reason)
	}
	if fromConfigSync {
		reason := "resourcegroups.kpt.dev generated by ConfigSync cannot be modified by other means"
		return admission.Denied(reason)
	}
	reason := "Allow resourcegroups.kpt.dev that are not generated by ConfigSync"
	return admission.Allowed(reason)
}

// fromConfigSync returns true if the ResourceGroup is generated by ConfigSync.
func fromConfigSync(req admission.Request) (bool, error) {
	name := req.Name
	namespace := req.Namespace

	labels, err := metadataAccessor.Labels(req.Object.Object)
	if err != nil {
		return false, err
	}

	hasInventoryLabel := labels[common.InventoryLabel] == kptapplier.InventoryID(namespace)

	if namespace == configsync.ControllerNamespace {
		return name == v1alpha1.RootSyncName && hasInventoryLabel, nil
	}
	return name == v1alpha1.RepoSyncName && hasInventoryLabel, nil
}
