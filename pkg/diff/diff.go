// Package diff contains code for diffing sync-enabled resources, not
// necessarily known at compile time.
package diff

import (
	"github.com/google/nomos/pkg/core"
	"github.com/google/nomos/pkg/declared"
	"github.com/google/nomos/pkg/kinds"
	"github.com/google/nomos/pkg/lifecycle"
	"github.com/google/nomos/pkg/status"
	"github.com/google/nomos/pkg/syncer/differ"
	"github.com/google/nomos/pkg/syncer/reconcile"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// Type indicates the state of the given resource
type Type string

const (
	// NoOp indicates that no action should be taken.
	NoOp = Type("no-op")

	// Create indicates the resource should be created.
	Create = Type("create")

	// Update indicates the resource is declared and is on the API server, so we should
	// calculate a patch and apply it.
	Update = Type("update")

	// Delete indicates the resource should be deleted.
	Delete = Type("delete")

	// Error indicates the resource's management annotation in the API server is invalid.
	Error = Type("error")

	// Unmanage indicates the resource's management annotation should be removed from the API Server.
	Unmanage = Type("unmanage")

	// ManagementConflict represents the case where Declared and Actual both exist,
	// but the Actual one is managed by a Reconciler that supersedes this one.
	ManagementConflict = Type("management-conflict")
)

// Diff is resource where Declared and Actual do not match.
// Both Declared and Actual are core.Object.
type Diff struct {
	// Declared is the resource as it exists in the repository.
	Declared core.Object
	// Actual is the resource as it exists in the cluster.
	Actual core.Object
}

// Type returns the type of the difference between the repository and the API Server.
func (d Diff) Type(manager declared.Scope) Type {
	if d.Declared != nil {
		// The resource IS in the repository.
		if differ.ManagementEnabled(d.Declared) {
			// The declared resource has been annotated as managed.
			// We do this automatically when parsing objects, before they get to the
			// Applier.
			if d.Actual != nil {
				if !CanManage(manager, d.Actual) {
					// The declared object's manager can't manage the resource as it exists
					// on the cluster.
					return ManagementConflict
				}

				// The resource is also in the cluster, so update it.
				return Update
			}
			// The resource is not in the cluster, so create it.
			return Create
		}
		if differ.ManagementDisabled(d.Declared) {
			// The resource is explicitly marked management disabled in the repository.
			if d.Actual != nil {
				if differ.HasNomosMeta(d.Actual) {
					// Management is disabled for the resource, so remove the annotation from the API Server.
					return Unmanage
				}
			}
			// Management is disabled and there's no required changes to the resource.
			return NoOp
		}
		// The annotation in the repo is invalid, so show an error.
		return Error
	}

	// The resource IS NOT in the repository.
	if d.Actual != nil {
		// The resource IS on the API Server.
		if len(d.Actual.GetOwnerReferences()) > 0 {
			// We disallow deleting resources with owner references.
			// So, do not attempt to delete resources on cluster with this field specified.
			// Most likely the actual resource was generated by a controller and had the
			// owner object's managed annotations propagated down to it.
			//
			// For example, if a Deployment is managed with Nomos, it will generate a ReplicaSet
			// that will inherit all the Deployment's annotations, including the managed
			// annotations. We will ignore the ReplicaSet because the ReplicaSet will have its
			// OwnerReference field set.
			return NoOp
		}

		if !differ.HasNomosMeta(d.Actual) {
			// No Nomos annotations or labels, so don't do anything.
			return NoOp
		}

		if differ.ManagementEnabled(d.Actual) {
			// There are Nomos annotations or labels on the resource.

			if lifecycle.HasPreventDeletion(d.Actual) {
				// This object is marked with the lifecycle annotation that says to not
				// delete it. We should orphan the objects by unmanaging them.
				return Unmanage
			}

			if (d.Actual.GroupVersionKind().GroupKind() == kinds.Namespace().GroupKind()) &&
				differ.IsManageableSystemNamespace(d.GetName()) {
				// Don't delete this Namespace from the cluster; unmanage it.
				// The Syncer never creates a differ.Diff with a Namespace, so this only
				// happens in the Remediator.
				return Unmanage
			}

			// Delete resource with management enabled on API Server.
			return Delete
		}

		// The actual resource has Nomos artifacts and is explicitly unmanaged.
		return Unmanage
	}

	// The resource is neither on the API Server nor in the repo, so do nothing.
	return NoOp
}

// UnstructuredActual returns the actual as an unstructured object.
func (d Diff) UnstructuredActual() (*unstructured.Unstructured, status.Error) {
	if d.Actual == nil {
		return nil, nil
	}
	// We just want Unstructured, NOT sanitized. Sanitized removes required fields
	// such as resourceVersion, which are required for updates.
	return reconcile.AsUnstructured(d.Actual)
}

// UnstructuredDeclared returns the declared as an unstructured object.
func (d Diff) UnstructuredDeclared() (*unstructured.Unstructured, status.Error) {
	if d.Declared == nil {
		return nil, nil
	}
	return reconcile.AsUnstructuredSanitized(d.Declared)
}

// ThreeWay does a three way diff and returns the FileObjectDiff list.
// Compare between previous declared and new declared to decide the delete list.
// Compare between the new declared and the actual states to decide the create and update.
func ThreeWay(newDeclared, previousDeclared, actual map[core.ID]core.Object) []Diff {
	var diffs []Diff
	// Delete.
	for coreID, previousDecl := range previousDeclared {
		if _, ok := newDeclared[coreID]; !ok {
			toDelete := Diff{
				Declared: nil,
				Actual:   previousDecl,
			}
			diffs = append(diffs, toDelete)
		}
	}
	// Create and Update.
	for coreID, newDecl := range newDeclared {
		if actual, ok := actual[coreID]; !ok {
			toCreate := Diff{
				Declared: newDecl,
				Actual:   nil,
			}
			diffs = append(diffs, toCreate)
		} else {
			toUpdate := Diff{
				Declared: newDecl,
				Actual:   actual,
			}
			diffs = append(diffs, toUpdate)
		}
	}
	return diffs
}

// TwoWay does a two way diff and returns the FileObjectDiff list.
func TwoWay(declared, actual map[core.ID]core.Object) []Diff {
	return ThreeWay(declared, nil, actual)
}

// GetName returns the metadata.name of the object being considered.
func (d *Diff) GetName() string {
	if d.Declared != nil {
		return d.Declared.GetName()
	}
	if d.Actual != nil {
		return d.Actual.GetName()
	}
	// No object is being considered.
	return ""
}
