package nomostest

import (
	"strings"
	"testing"

	v1 "github.com/google/nomos/pkg/api/configmanagement/v1"
	"github.com/google/nomos/pkg/core"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// TestLabel is the label added to all test objects, ensuring we can clean up
// non-ephemeral clusters when tests are complete.
const TestLabel = "nomos-test"

// TestLabelValue is the value assigned to the above label.
const TestLabelValue = "enabled"

// AddTestLabel is automatically added to objects created or declared with the
// NT methods, or declared with Repository.Add.
//
// This isn't perfect - objects added via other means (such as kubectl) will
// bypass this.
var AddTestLabel = core.Label(TestLabel, TestLabelValue)

// Clean removes all objects of types registered in the scheme, with the above
// caveats. It should be run before and after a test is run against any
// non-ephemeral cluster.
//
// It is unnecessary to run this on Kind clusters that exist only for the
// duration of a single test.
func Clean(nt *NT) {
	nt.T.Helper()

	// errDeleting ensures we delete everything possible to delete before failing.
	errDeleting := false
	for gvk := range nt.scheme.AllKnownTypes() {
		// Only try to list types that have *List types associated with them, as they
		// are guaranteed to be listable.
		if !strings.HasSuffix(gvk.Kind, "List") || strings.HasSuffix(gvk.Kind, "StatusList") {
			continue
		}

		list := &unstructured.UnstructuredList{}
		list.GetObjectKind().SetGroupVersionKind(gvk)
		var opts []client.ListOption
		if gvk.Kind != "SyncList" {
			// For Syncs we can't rely on the TestLabel as this is generated by the
			// controller. We want all Syncs to be deleted.
			opts = append(opts, &client.MatchingLabels{TestLabel: TestLabelValue})
		}
		err := nt.Client.List(nt.Context, list, opts...)
		if err != nil && !meta.IsNoMatchError(err) && !apierrors.IsNotFound(err) {
			// Ignore cases where the type doesn't exist on the cluster. Obviously
			// there isn't anything to clean in that case.
			nt.T.Errorf("unable to clean objects of type %v from cluster: %v", gvk, err)
			errDeleting = true
		}

		for _, u := range list.Items {
			finalizers := u.GetFinalizers()
			if len(finalizers) == 1 && finalizers[0] == v1.SyncFinalizer {
				// Special case logic for the SyncFinalizer, as objects may get stuck
				// with it. We don't really care to wait for/rely on the controller to do
				// its cleanup as it may have exited in an error state.
				u.SetFinalizers([]string{})
				err = nt.Client.Update(nt.Context, &u)
				if err != nil {
					nt.T.Errorf("unable to remove syncer finalizer from object %v: %v", u.GroupVersionKind(), err)
				}
			}

			err = nt.Client.Delete(nt.Context, &u)
			if err != nil && !apierrors.IsNotFound(err) {
				nt.T.Errorf("unable to clean test object from cluster: %v", err)
				errDeleting = true
			}
		}
	}
	if errDeleting {
		nt.T.Fatal("error cleaning cluster")
	}
}

// FailIfUnknown fails the test if the passed type is not declared in the passed
// scheme.
func FailIfUnknown(t *testing.T, scheme *runtime.Scheme, o runtime.Object) {
	t.Helper()

	gvks, _, _ := scheme.ObjectKinds(o)
	if len(gvks) == 0 {
		t.Fatalf("unknown type %T %v. Add it to nomostest.newScheme().", o, o.GetObjectKind().GroupVersionKind())
	}
}
